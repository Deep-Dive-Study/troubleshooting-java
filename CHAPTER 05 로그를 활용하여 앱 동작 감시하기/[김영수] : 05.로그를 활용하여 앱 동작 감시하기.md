# chapter05 로그를 활용하여 앱 동작 감시하기

로그 메시지를 통해  앱 실행 중에 어떤 일이 일어나는지 조사할 때 사용한다. 주로 문제가 발생하면 로그를 통해 어떤 기법을 사용해 조사할지 결정하기 때문에, 로그 메시지는 매우 중요하다고 할 수 있다.

**로그에 포함되어야 하는 정보**

- 기록 시점 타임스탬프
- 심각도
- 로그 메시지
- 이벤트 발생 위치

# 5.1 로그를 이용하여 조사하기

로그 메시지의 가장 큰 장점은 특정 코드의 실행을 시각화 하는 능력이다.

로그가 디버거와 가장 큰 차이점은 실행 이력에 대한 자세한 정보를 갖는다.

로그를 사용할 때에는 항상 앱이 실행되는 시스템의 **표준 시간대**를 제일 먼저 체크해야 한다. 이는 혼동을 야기하기 때문이다.

## 5.1.1 로그에 기록된 예외 식별

로그를 보면 예외 스택 트레이스가 발견되는데, 예외 이름과 관련 스택트레이스를 확인해야 한다.

예를들면 NPE같은게 있다.

## 5.1.2 예외 스택 트레이스로 어디서 메서드를 호출했는지 식별

예외 스택 트레이스를 로깅해 메서드 호출 라인을 알아내는 방법이다.

예외 스택 트레이스를 확인하면 메서드 호출 체인을 표시하는데, 디버깅이 불가능한 상황에서 메서드 호출지를 식별할 수 있다.

```java
new Exception().printStackTrace();
```

이렇게 하면 예외는 던지지 않기 때문에 로직을 전혀 방해하지 않는다.

출련된 스택 트레이스는 실행 흐름을 식별하는데 큰 도움이 된다.

## 5.1.3 멀티스레드 아키텍처에서 커맨드의 실행 시간 측정

로그 메시지를 보면 커맨드의 실행 시간을 측정할 수 있다. (타임스탬프)

문제를 일으키는 인숫값을 찾아내려면 쿼리와 그 실행 시간을 로그에 기록하면 된다. 찾은 쿼리를 통해 쿼리를 튜닝하면 된다.

예시)

- 메서드 실행 이전을 타임스탬프로 로깅
- 실행 시간을 측정하려는 메서드 실행
- 메서드 종류 후 타임스탬프 차이를 계산 및 출력

이는 간단하지만 아주 효과적인 방법으로, 임시로 사용하기 좋다. 추후에는 코드의 가독성을 떨어트리기 때문에 가급적 오래 사용하지 않는게 좋다.

## 5.1.4 멀티스레드 아키텍처에서 커맨드 실행 문제 조사

멀티스레드 상황에서 디버거로 실행을 중단시키면 앱 실행에 간섭이 생겨 원래 조사하려던 시나리오와 다르게 될 수 있다.

이럴 때 **로그를 사용**하면 실행 중인 앱에 미치는 영향도를 낮출 수 있다. (간섭이 없진 않다)

로그에 타임스탬프와 함께 실행중인 스레드도 함께 기록하는 것이 좋다.

# 5.2 로깅을 구현하는 방법

## 5.2.1 로그 메시지 저장

로그는 영구 저장이 가능한 특징이 있다.

로그를 저장하는 방법

- 비관계형 DB
    
    성능과 일관성 사이의 균형을 맞출 수 있는 방법으로, 가장 일반적인 방법이다. (ELK, Splunk)
    
- 파일 시스템
    
    예전에 사용하는 방식으로, 속도가 떨어지고, 검색이 어려워 잘 사용하지 않는다.
    
- RDBMS
    
    데이터 일관성을 확실히 보장하고, 조회하기 좋다. 다만 성능 저하가 어느정도 있다. 따라서 대개 일관성을 포기하고 성능을 취한다.
    

## 5.2.2 로깅 레벨을 정의하고 로깅 프레임워크를 사용하는 방법

로깅 레벨

- Debug : 아주 중대한 문제로, 반드시 기록해야 한다. 보통 예상치 못한 예외를 기록한다.
- Info : 잠재적으로 에러일 수 있으나 앱이 처리한 이벤트, 타사 시스템과 연동이 실패했지만, 재시도로 성공했을 때
- Warn : common한 상황에서 앱의 정상 작동 유무에 대한 실행 이벤트
- Error : Info 메시지만으로 불충분한 경우에 세분화한다.

**ETC**

- 앱을 조사할 때 Debug는 필요하지 않아 대부분 비활성화되어 있다. 필요할 때 사용하자.
- System.out 또는 printStackTrace()는 비효율적이니 로깅 프레임워크를 사용하자.

**로깅 관련 설정(Log4j)**

![image](https://github.com/Deep-Dive-Study/troubleshooting-java/assets/85796588/61deafeb-21ba-4910-a3a4-0b6846baed26)

- logger : 어떤 메시지를 어느 어펜더에 기록할 지
- appender : 로그 메시지를 어디에 기록할 지
- formatter : 메시지를 어떻게 출력할 지
- 메시지 설정
    
    ```java
    <?xml version="1.0" encoding="UTF-8"?>
    <Configuration status="WARN">
    	<Appenders> //어펜더 정의
    		<Console name="Console" target="SYSTEM-OUT">
    			<PatternLayout pattern="%d{VV-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} -%msg%n"/>
    		</Console>
    	</Appenders>
    	<Loggers>  //로거 설정
    		<Root level="info">
    			<AppenderRef ref="Console"/>
    		</Root>
    	</Loggers>
    <Configuration>
    ```
    
    - appender : Console이라는 어펜더를 정의했다 이는 SYSTEM-OUT 스트림으로 내보낸다.
    - logger : Root 로거는 Info 이상의 메시지를 Console 어펜더에 전달한다.
    - formatter : pattern에 지정한 메시지 형태로 포맷을 맞춰 보낸다.

## 5.2.3 로깅 때문에 발생하는 문제와 예방 조치

- 보안 및 프라이버시 문제 : 개인정보 노출 → 로그는 많은 개발자가 보기 때문에 민감한 정보는 넣지 않는다.
- 성능 문제 : 로그가 지나치게 크면 문제가 된다. → 너무 많이 기록하지 말고, 꼭 필요한 메시지만 저장하라.
- 유지보수 문제 : 소스코드 가독성이 떨어진다. → 가장 연관성이 큰 세부정보만 제공하고, 나중에 추가하라

# 5.3 로그와 원격 디버깅

![image](https://github.com/Deep-Dive-Study/troubleshooting-java/assets/85796588/15cad133-cb58-417f-b13b-056a4c72ddbc)

로그와 원격 디버깅 모두 원격 환경에서 앱의 동작을 파악할 수 있다.

단, 각각의 장단점이 다르다. 선택은 개발자의 취향과 선호도에 다르다.

# 요약

- 문제 조사를 시작할 때 로그로 방향성을 정해라.
- 로그에는 타임스탬프는 필수이다.
- 로그는 꼭 필요할 때만 사용하자, 남발하지 말자
- 로그에 민감한 정보는 남기지 말자.
