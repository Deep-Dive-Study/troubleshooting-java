# 부록D : 자바 스레드 이해

# D.1 스레드란 무엇인가?

스레드 : 실행 중인 프로세스에서 독립적인 일련의 작업

모든 프로세스는 다수의 스레드를 가질 수 있으며, 여러 태스크를 앱에서 병렬로 실행하고, 순서는 없다.

![image](https://github.com/Deep-Dive-Study/troubleshooting-java/assets/85796588/bc75e3c8-74f3-4fa5-b4a3-688618c88e8f)

스레드는 각각 독립적이기 때문에, 메인 스레드가 종료 되더라도 모든 스레드가 종료되기 전까지 프로세스는 종료되지 않는다.

순서가 없다는 뜻은 다음 그림을 보고 이해하면 된다.

![image](https://github.com/Deep-Dive-Study/troubleshooting-java/assets/85796588/2b473d22-ded3-4e0d-b20e-11219346c0bf)

# D.2 스레드의 수명 주기

스레드 실행을 이해할 때 스레드 수명 주기를 파악하는 일도 필수다. 스레드 상태는 스레드의 실행 파악에 중요하다.

스레드 주요 상태

- New : 인스턴스화 직후 시작되긴 전 스레드의 상태 / 이 상태의 스레드는 단순 자바 객체로 커맨드 실행 불가
- Runnable : start() 메서드가 호출된 이후 / JVM은 스레드에 커맨드를 실행할 수 있으며 하위 상태로 만든다.
    - Ready : 스레드는 실행되지 않지만, 언제라도 실행할 수 있는 상태
    - Running : 스레드가 실행 중인 상태. 현재 CPU가 커맨드를 실행하고 있다.
- Blocked : 스레드가 시작은 되었으나 일시적으로 실행 가능 상태가 아님 / 이 상태는 스레드를 실행할 수 없도록 일시적으로 JVM에서 스레드를 숨겨 스레드 실행을 제어하려고 할 때 유용하다. / Blocked 상태의 스레드는 다음 하위 상태중 하나에 있다.
    - Monitored : 스레드가 동기화 블록의 모니터에 의해 중단되고 해당 블록을 실행하기 위해 해제를 기다림
    - Waiting : 실행 도중 모니터의 wait() 메서드가 호출되어 중단된 상태. nofity() or notifyAll() 메서드가 호출될 때까지 스레드는 차단 상태를 유지한다.
    - Slepping : Thread.sleep() 메서드가 호출되어 현재 스레드를 지정된 시간동안 중단한다. / 시간이 지난 뒤 다시 Runnable 상태가 된다.
    - Parked : waiting과 거의 같다. 누군가 park() 메서드를 호출하면 현재 스레드는 이 상태로 바뀌며, 이후 unpark() 메서드가 호출될 때 까지 계속 차단된다.
- Dead : 스레드는 커맨드 집합을 실행 완료하거나, Error or Exception 때문에 중단되거나 다른 스레드에 의해 중단될 경우 종료된다. / 한 번 종료된 스레드는 재시작할 수 없다.

![image](https://github.com/Deep-Dive-Study/troubleshooting-java/assets/85796588/f0ef7bbc-a0a9-460c-96dd-2e264b7e6793)

# D.3 스레드 동기화

## D.3.1 동기화 블록

synchronized는 스레드를 동기화하는 가장 간단한 방법이다. 이에는 두 가지 옵션이 있다.

- block synchronization : 주어진 코드 블록에 synchronized 수정자를 적용한다.
- method synchronization : 메서드에 synchronized 수정자를 적용한다.
    - 메서드 구문에 암묵적으로 this 또는 클래스 타입 인스턴스가 포함되어 있다.

모든 동기화 블록에는 두가지 중요한 구성 요소가 있다.

- 모니터 : 동기화 커맨드의 실행을 관장하는 객체
- 커맨드 블록 : 동기화한 실제 커맨드

![image](https://github.com/Deep-Dive-Study/troubleshooting-java/assets/85796588/19068334-66d5-4c7c-9841-ee82f5797bc8)

다음과 같이 동기화 블록이 동일한 모니터를 사용하면 두 블록은 동기화가 된다.

하지만 모니터가 다르다면, 두 스레드는 전혀 동기화되지 않는다.

프로파일러나 스레드 덤프로 문제를 조사할 땐 스레드가 차단된 경위를 파악해야 한다.

## D.3.2 wait(), nofity(), notifyAll() 사용

동기화 블록의 모니터에서 wait() 메서드를 사용하면 스레드를 무한 대기시킬 수 있다.

다른 스레드가 notify() or notifyAll() 메서드를 통해 실행을 재개시킬 수 있다. 

위 방법은 스레드 강제 종료로 앱 성능개선에 쓰인다. 주의해야할 점은 데드락 또는 무한 대기할 수 있다.

wait(), notify(), notifyAll()은 동기화 블록에서만 효과가 있다.

wait() 메서드를 사용하면 스레드를 차단하고, 획득한 락도 함께 반환한다.

또한, nofity()는 프로듀서-컨슈머 방식일 때 사용하기도 한다.

## D.3.3 스레드 조인

다른 스레드가 실행을 완료할 때까지 대기시켰다가 어느 시점에서 스레드를 조인하는 방식도 자주 쓰인다.

스레드는 그냥 다른 스레드가 실행을 마칠 때까지 기다린다.

![image](https://github.com/Deep-Dive-Study/troubleshooting-java/assets/85796588/273ea7c1-0297-4091-a1fd-f342e568e2fb)

독립적인 스레드를 사용하면 처리 시간을 줄일 수 있다. 스레드 조인을 잘못 사용하면 적체되거나, 영원히 실행되지 않을 수 있다.

## D.3.4 정해진 시간동안 스레드 차단

- sleep() : Thread 클래스에 있는 스태틱 메서드를 사용하면 정해진 시간 동안 기다리게 할 수 있다.
- wait(long timeout) : timeout이 지나면 스레드를 자동으로 꺠운다.
- join(long timeout) : join() 메서드와 동일하나, 주어진 타임아웃 시간이 지나면 자동으로 조인한다.

wait() 대신 sleep()을 사용하게 되면 최적의 성능을 얻을 수 없다.

## D.3.5 스레드와 블로킹 객체 동기화하기

멀티스레드 동기화에 유용한 클래스

- Semaphore : 스레드 수 제한 객체
- CyclicBarrier : 주어진 코드 블록을 실행하기 위해 특정 개수 이상의 스레드가 액티브인지 확인
- Lock : 좀 더 광범위한 동기화 옵션 제공
- Latch : 다른 스레드의 특정 로직이 수행될 때까지 일부 스레드

# D.4 멀티스레드 아키텍처의 일반적인 문제

- 경쟁 상태 : 둘 이상의 스레드가 공유된 리소스를 서로 고치려고 경쟁한다.
- 데드락 : 둘 이상의 스레드가 서로를 기다린다
- 리브락 : 둘 이상의 스레드가 중단 조겅늘 만족하지 못하여 아무런 의미 있는 일을 하지 못한 채 계속 실행된다.
- 기아 : JVM이 다른 스레드를 실행하는 동안 스레드가 지속적으로 차단된다.

## D.4.1 경쟁 상태

여러 스레드가 동일한 리소스를 변경하려하면 경우에 따라 각기 다른 아웃풋이 나온다.

또한 시나리오를 재현하기 어렵고, 조사하기 어렵다.

## D.4.2 데드락

데드락 조건

- 상호 배제
- 점유 대기
- 비선점
- 순환 대기

데드락은 7~9장 내용을 통해 프로파일링 하자

## D.4.3 리브락

리브락에 빠지면 스레드가 중단되어야 하는데도 계속 실행된다. 실행하며 리소스를 무차별적으로 소모하기 때문에 성능 문제를 일으킨다.

![image](https://github.com/Deep-Dive-Study/troubleshooting-java/assets/85796588/a939fe7b-9f55-45ec-bde1-7e88d536801e)

다음과 같이 서로를 종료하지 못하도록 조건을 변경한다. 해결 방법은 데드락과 같다

## D.4.4 기아

특정 스레드가 실행 대상에서 지속적으로 배제되는 것으로, 기아 상태는 거의 일어나지 않는다.
